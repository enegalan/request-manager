{"version":3,"file":"request-manager.js","sources":["../main.js"],"sourcesContent":["/**\n * RequestManager - A library for managing and regulating HTTP requests efficiently.\n * @license MIT\n * This library allows you to manage HTTP requests from any library (ajax, Ext.Ajax, axios, fetch, etc.)\n * by accepting Promises as parameters. When a request is repeated with the same identifier,\n * the previous request is automatically cancelled and the new one is executed, giving priority to the most recent requests.\n\n * @param {Object} managerOptions - The options for the manager\n * @param {boolean} managerOptions.verbose - If true, cancellation errors will include messages\n * @returns {RequestManager} A new RequestManager instance\n*/\nclass RequestManager {\n    constructor(managerOptions = {}) {\n        /**\n         * Map to store active requests by their unique identifier.\n         * Each entry contains:\n         * - promise: The original promise\n         * - abortController: AbortController instance (if available)\n         * - cancelToken: Cancel token (for axios compatibility)\n         * - wrapperPromise: The promise that wraps the request\n         * - resolveWrapper: The function to resolve the wrapper promise\n         * - rejectWrapper: The function to reject the wrapper promise\n         * - isCancelled: Whether the request has been cancelled\n         * - verbose: Whether to include verbose messages in the cancellation error\n         */\n        this.activeRequests = new Map();\n        /**\n         * Verbose mode: if true, cancellation errors will include messages\n         * @type {boolean}\n         */\n        this.verbose = managerOptions.verbose || false;\n        /**\n         * Manager options: the options that were passed to the constructor\n         * @type {Object}\n         */\n        this.managerOptions = managerOptions;\n        /**\n         * Options for the current request: will be flushed after the request is completed\n         * @type {Object}\n         */\n        this.options = {};\n        /**\n         * AbortController instance for the current request: will be flushed after the request is completed\n         * @type {AbortController}\n         */\n        this.abortController = null;\n    }\n\n    /**\n     * Flushes the options for the current request\n     * @private\n     */\n    #_flushRequestOptions() {\n        this.options = {};\n    }\n\n    /**\n     * Gets the manager options\n     * @returns {Object} Manager options\n     */\n    getOptions() {\n        return this.managerOptions;\n    }\n\n    /**\n     * Sets the manager options\n     * @param {Object} options - The options to set\n     */\n    setOptions(options) {\n        this.managerOptions = options;\n        if (options.verbose !== undefined) {\n            this.verbose = options.verbose;\n        }\n    }\n\n    /**\n     * Sets the options for the current request\n     * @param {Object} options - The options to set\n     * @private\n     */\n    #_setRequestOptions(options) {\n        this.options = options;\n    }\n\n    /**\n     * Creates an AbortController and returns its signal.\n     * The AbortController is stored internally and will be used by the next request() call.\n     * This allows users to get the signal before creating the request.\n     * \n     * @returns {AbortSignal} The signal from a new AbortController\n     * \n     * @example\n     * const signal = requestManager.getSignal();\n     * requestManager.request('/api/users', fetch('/api/users', { signal }));\n     */\n    getSignal() {\n        return this.getAbortController().signal;\n    }\n\n    /**\n     * Gets the current AbortController instance\n     * Creates a new AbortController if none exists or if the current one is aborted\n     * @returns {AbortController} The current AbortController instance\n     */\n    getAbortController() {\n        // Create a new AbortController if none exists or if the current one is aborted\n        if (!this.abortController || this.abortController.signal.aborted) {\n            this.abortController = new AbortController();\n        }\n        return this.abortController;\n    }\n\n    /**\n     * Clears the current AbortController\n     * @private\n     */\n    #_clearAbortController() {\n        this.abortController = null;\n    }\n\n    /**\n     * Generates a request identifier based on the requestKey or URL\n     * @param {string} url - The URL of the request\n     * @param {string|number|Function} requestKey - Optional key to generate a deterministic ID.\n     *                                              If provided, requests with the same key will share the same ID.\n     *                                              If null or undefined, the cleaned URL will be used as the key.\n     * @param {boolean} noCancel - If true, generates a unique ID to prevent cancellation\n     * @returns {string} A unique request identifier\n     * @private\n     */\n    #_generateRequestId(url, requestKey = null, noCancel = false) {\n        if (noCancel) { // Generate a unique ID to prevent cancellation\n            return `request_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;\n        }\n        if (requestKey !== null && requestKey !== undefined) {\n            if (typeof requestKey === 'function') {\n                try {\n                    requestKey = requestKey();\n                } catch (error) {\n                    requestKey = null;\n                }\n            }\n            if (requestKey !== null && requestKey !== undefined) return `request_${String(requestKey)}`;\n        }\n        // Use cleaned URL as key when requestKey is null/undefined\n        let cleanedUrl = url || '';\n        let hasProtocol = cleanedUrl.includes('://');\n        if (hasProtocol) cleanedUrl = cleanedUrl.split('://')[1];\n        let hasParams = cleanedUrl.includes('?');\n        if (hasParams) cleanedUrl = cleanedUrl.split('?')[0];\n        let hasHash = cleanedUrl.includes('#');\n        if (hasHash) cleanedUrl = cleanedUrl.split('#')[0];\n        return `request_${cleanedUrl}`;\n    }\n\n    /**\n     * Prepares fetch options by merging options and removing custom properties\n     * @param {Object} options - Configuration options\n     * @param {AbortSignal} signal - Abort signal to add to fetch options\n     * @param {Object} additionalOptions - Additional options to merge\n     * @returns {Object} Prepared fetch options\n     * @private\n     */\n    #_prepareFetchOptions(options, signal, additionalOptions = {}) {\n        const fetchOptions = Object.assign({}, additionalOptions);\n        const customOptions = ['abortController', 'cancelToken', 'requestKey', 'noCancel'];\n        Object.keys(options).forEach(key => {\n            if (customOptions.includes(key)) return;\n            fetchOptions[key] = options[key];\n        });\n        fetchOptions.signal = signal;\n        return fetchOptions;\n    }\n\n    /**\n     * Internal method that handles the core request logic.\n     * \n     * @param {string} requestId - Unique identifier for the request\n     * @param {Promise|Function|string} requestPromise - The request promise, function, or URL string\n     * @param {Object} options - Configuration options\n     * @param {AbortController} options.abortController - AbortController instance\n     * @param {Function} options.cancelToken - Cancel token or cancel function\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * @private\n     */\n    #_request(requestId, requestPromise, options = {}) {\n        this.#_setRequestOptions(options);\n        if (!options.abortController) this.#_clearAbortController(); // Clear any existing abortController to ensure each request gets a fresh one\n        this.#_flushRequestOptions();\n        const abortController = options.abortController || this.getAbortController();\n\n        // Handle different types of requestPromise inputs\n        // Priority: Function (Custom logic) > String (URL) > Promise (axios, fetch, etc.)\n        if (typeof requestPromise === 'function') {\n            // Function: custom logic for any library (axios, ajax, etc.)\n            const fetchOptions = this.#_prepareFetchOptions(options, abortController.signal);\n            requestPromise = requestPromise({ options: fetchOptions });\n        } else if (typeof requestPromise === 'string') {\n            // String (URL): make fetch internally\n            const fetchOptions = this.#_prepareFetchOptions(options, abortController.signal);\n            requestPromise = fetch(requestPromise, fetchOptions);\n        }\n\n        // Cancel previous request with the same ID if it exists\n        if (!options.noCancel) this.cancel(requestId);\n\n        // Create a wrapper promise that will be resolved/rejected based on the request\n        let resolveWrapper, rejectWrapper;\n        const wrapperPromise = new Promise((resolve, reject) => {\n            resolveWrapper = resolve;\n            rejectWrapper = reject;\n        });\n\n        // Store the request information\n        const requestInfo = {\n            promise: requestPromise,\n            abortController: abortController,\n            cancelToken: options.cancelToken || null,\n            wrapperPromise: wrapperPromise,\n            resolveWrapper: resolveWrapper,\n            rejectWrapper: rejectWrapper,\n            isCancelled: false,\n            verbose: this.verbose\n        };\n\n        this.activeRequests.set(requestId, requestInfo);\n\n        // Handle request promise completion\n        if (requestPromise && typeof requestPromise.then === 'function') {\n            try {\n                let req = requestPromise.then((result) => {\n                    if (this.activeRequests.get(requestId) === requestInfo && !requestInfo.isCancelled) {\n                        this.activeRequests.delete(requestId);\n                        resolveWrapper(result);\n                    }\n                });\n                if (req.catch) req.catch((error) => {\n                    onError(this, error);\n                });\n            } catch (error) {\n                onError(this, error);\n            }\n            function onError(scope, error) {\n                // Check if this requestInfo is still the active one, or if it was cancelled\n                const currentRequestInfo = scope.activeRequests.get(requestId);\n                if (currentRequestInfo !== requestInfo) return;\n                // Only delete if this is still the active request\n                scope.activeRequests.delete(requestId);\n                if (!requestInfo.isCancelled) rejectWrapper(error);\n                else if (requestInfo.isCancelled && requestInfo.verbose) rejectWrapper(new Error('Request was cancelled'));\n            }\n        } else {\n            // If requestPromise is not a promise, we can't track its completion automatically\n            // This can happen with libraries like ExtJS that return request objects instead of promises\n            // In this case, the user should handle the request object themselves\n            // We'll resolve the wrapper promise immediately to prevent it from hanging\n            // The user can still use the request object returned by the library\n            setTimeout(() => {\n                if (this.activeRequests.get(requestId) === requestInfo && !requestInfo.isCancelled) {\n                    this.activeRequests.delete(requestId);\n                    resolveWrapper(requestPromise); // Resolve with the request object so the user can use it\n                }\n            }, 0);\n        }\n        return wrapperPromise;\n    }\n\n    /**\n     * Executes an HTTP request, cancelling any previous request with the same identifier.\n     * \n     * @param {string} url - The URL to request\n     * @param {Promise|Function} requestPromise - The request promise or function that returns a promise\n     * @param {Object} options - Optional configuration\n     * @param {string|number|Function} options.requestKey - Key to identify duplicate requests.\n     *                                                    If provided, requests with the same key will cancel previous ones.\n     *                                                    Can be a string, number, or function that returns a key.\n     * @param {AbortController} options.abortController - AbortController instance (created automatically if not provided)\n     * @param {Function} options.cancelToken - Cancel token or cancel function for other libraries\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID, allowing concurrent requests\n     *                                                    Any other properties are passed as fetch options (method, headers, body, etc.)\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * \n     * @example\n     * // Request with Promise\n     * requestManager.request('/api/users', axios.get('/api/users', { cancelToken: axios.CancelToken.source().token }));\n     * \n     * @example\n     * // Request with Function\n     * requestManager.request('/api/users', ({ options }) => fetch('/api/users', { signal: options.signal, ...options }));\n     * \n     * @example\n     * // Request with Promise and custom cancellation grouping with requestKey\n     * const options = {\n     *   requestKey: 'get-users',\n     *   cancelToken: axios.CancelToken.source().cancel\n     * }\n     * requestManager.request('/api/users', axios.get('/api/users', options), options);\n     * \n     * @example\n     * // Request with noCancel to allow concurrent requests (e.g., lazy loading)\n     * requestManager.request('/api/lazy?load=1', fetch('/api/lazy?load=1'), { noCancel: true });\n     * requestManager.request('/api/lazy?load=2', fetch('/api/lazy?load=2'), { noCancel: true });\n     * // Both requests will execute concurrently without canceling each other\n     */\n    request(url, requestPromise, options = {}) {\n        const requestOptions = options || {};\n        const requestId = this.#_generateRequestId(url, requestOptions.requestKey, requestOptions.noCancel);\n        return this.#_request(requestId, requestPromise, requestOptions);\n    }\n\n    /**\n     * Executes an HTTP request using fetch, cancelling any previous request with the same identifier.\n     * \n     * @param {string} url - The URL to fetch\n     * @param {Object} options - Optional configuration\n     * @param {string|number|Function} options.requestKey - Key to identify duplicate requests.\n     *                                                    If provided, requests with the same key will cancel previous ones.\n     *                                                    Can be a string, number, or function that returns a key.\n     * @param {AbortController} options.abortController - AbortController instance (created automatically if not provided)\n     * @param {Function} options.cancelToken - Cancel token or cancel function for other libraries\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID, allowing concurrent requests\n     *                                                    Any other properties are passed as fetch options (method, headers, body, etc.)\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * \n     * @example\n     * // Simple GET request\n     * requestManager.fetch('/api/users');\n     * \n     * @example\n     * // POST request with options\n     * requestManager.fetch('/api/users', {\n     *   method: 'POST',\n     *   headers: { 'Content-Type': 'application/json' },\n     *   body: JSON.stringify({ name: 'John' })\n     * });\n     * \n     * @example\n     * // Request with requestKey for custom cancellation grouping with requestKey\n     * requestManager.fetch('/api/users', {\n     *   requestKey: 'get-users'\n     * });\n     * \n     * @example\n     * // Request with noCancel to allow concurrent requests (e.g., lazy loading)\n     * requestManager.fetch('/api/lazy?load=1', { noCancel: true });\n     * requestManager.fetch('/api/lazy?load=2', { noCancel: true });\n     * // Both requests will execute concurrently without canceling each other\n     */\n    fetch(url, options = {}) {\n        const requestOptions = options || {};\n        const requestId = this.#_generateRequestId(url, requestOptions.requestKey, requestOptions.noCancel);\n        return this.#_request(requestId, url, requestOptions);\n    }\n\n    /**\n     * Executes an HTTP request using axios, cancelling any previous request with the same identifier.\n     * \n     * @param {string} url - The URL to request\n     * @param {Object} options - Optional configuration\n     * @param {string|number|Function} options.requestKey - Key to identify duplicate requests.\n     *                                                    If provided, requests with the same key will cancel previous ones.\n     *                                                    Can be a string, number, or function that returns a key.\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID, allowing concurrent requests\n     *                                                    Any other properties are passed as axios options (method, headers, params, data, etc.)\n     * @param {Object} axiosInstance - Optional axios instance to use. If not provided, uses global axios.\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * \n     * @example\n     * // Simple GET request (uses global axios)\n     * requestManager.axios('/api/users');\n     * \n     * @example\n     * // With custom axios instance\n     * const myAxios = axios.create({ baseURL: 'https://api.example.com' });\n     * requestManager.axios('/users', {}, myAxios);\n     * \n     * @example\n     * // POST request with options\n     * requestManager.axios('/api/users', {\n     *   method: 'POST',\n     *   headers: { 'Content-Type': 'application/json' },\n     *   body: JSON.stringify({ name: 'John' })\n     * });\n     * \n     * @example\n     * // Request with requestKey for custom cancellation grouping with requestKey\n     * requestManager.axios('/api/users', {\n     *   requestKey: 'get-users'\n     * });\n     * \n     * @example\n     * // Request with noCancel to allow concurrent requests\n     * requestManager.axios('/api/lazy?load=1', { noCancel: true });\n     * requestManager.axios('/api/lazy?load=2', { noCancel: true });\n     */\n    axios(url, options = {}, axiosInstance = null) {\n        const requestOptions = options || {};\n        const axiosLib = axiosInstance || axios;\n        const cancelToken = axiosLib.CancelToken.source();\n        const requestId = this.#_generateRequestId(url, requestOptions.requestKey, requestOptions.noCancel);\n        return this.#_request(requestId, axiosLib.get(url, { cancelToken: cancelToken.token, ...requestOptions }), {\n            cancelToken: cancelToken,\n            ...requestOptions\n        });\n    }\n\n    /**\n     * Executes an HTTP request using jQuery.ajax, cancelling any previous request with the same identifier.\n     * \n     * @param {Function} ajaxFunction - A function that receives { url, ...options } and returns a Promise\n     * @param {string} url - The URL to request\n     * @param {Object} options - Optional configuration\n     * @param {string|number|Function} options.requestKey - Key to identify duplicate requests.\n     *                                                    If provided, requests with the same key will cancel previous ones.\n     *                                                    Can be a string, number, or function that returns a key.\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID, allowing concurrent requests\n     *                                                    Any other properties are passed to the ajax method function\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * \n     * @example\n     * // Simple GET request\n     * requestManager.ajax(ajaxFunction, '/api/users');\n     * \n     * @example\n     * // POST request with options\n     * requestManager.ajax(ajaxFunction, '/api/users', {\n     *   method: 'POST',\n     *   headers: { 'Content-Type': 'application/json' },\n     *   body: JSON.stringify({ name: 'John' })\n     * });\n     * \n     * @example\n     * // Request with requestKey for custom cancellation grouping with requestKey\n     * requestManager.ajax(ajaxFunction, '/api/users', {\n     *   requestKey: 'get-users'\n     * });\n     */\n    ajax(ajaxFunction, url, options = {}) {\n        if (typeof ajaxFunction !== 'function') throw new Error('ajaxFunction parameter must be a function');\n        const requestOptions = options || {};\n        const requestId = this.#_generateRequestId(url, requestOptions.requestKey, requestOptions.noCancel);\n        try {\n            const abortController = options.abortController || this.getAbortController();\n            const req = ajaxFunction({ url, ...requestOptions });\n            console.log('req', req, typeof req.abort);\n            if (req && typeof req.abort === 'function') {\n                this.addAbortListener(req.abort, abortController.signal);\n            }\n            return this.#_request(requestId, req, { ...requestOptions, abortController: abortController });\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    }\n\n    /**\n     * Executes an HTTP request using XMLHttpRequest, cancelling any previous request with the same identifier.\n     * \n     * @param {string} url - The URL to request\n     * @param {Object} options - Optional configuration\n     * @param {string} options.method - HTTP method (GET, POST, PUT, DELETE, etc.). Defaults to 'GET'.\n     * @param {Object} options.headers - Headers object to set on the request\n     * @param {string|FormData|Blob|ArrayBuffer} options.body - Request body\n     * @param {string} options.responseType - Response type ('text', 'json', 'blob', 'arraybuffer', 'document'). Defaults to 'text'.\n     * @param {boolean} options.withCredentials - Whether to send credentials with the request\n     * @param {number} options.timeout - Request timeout in milliseconds\n     * @param {string|number|Function} options.requestKey - Key to identify duplicate requests.\n     *                                                    If provided, requests with the same key will cancel previous ones.\n     *                                                    Can be a string, number, or function that returns a key.\n     * @param {boolean} options.noCancel - If true, this request will not cancel previous requests with the same ID, allowing concurrent requests\n     * @returns {Promise} A Promise that resolves/rejects based on the most recent request\n     * \n     * @example\n     * // Simple GET request\n     * requestManager.xhr('/api/users');\n     * \n     * @example\n     * // POST request with options\n     * requestManager.xhr('/api/users', {\n     *   method: 'POST',\n     *   headers: { 'Content-Type': 'application/json' },\n     *   body: JSON.stringify({ name: 'John' })\n     * });\n     * \n     * @example\n     * // Request with requestKey for custom cancellation grouping\n     * requestManager.xhr('/api/users', {\n     *   requestKey: 'get-users'\n     * });\n     * \n     * @example\n     * // Request with noCancel to allow concurrent requests\n     * requestManager.xhr('/api/lazy?load=1', { noCancel: true });\n     * requestManager.xhr('/api/lazy?load=2', { noCancel: true });\n     */\n    xhr(url, options = {}) {\n        const requestOptions = options || {};\n        const requestId = this.#_generateRequestId(url, requestOptions.requestKey, requestOptions.noCancel);\n        const xhrFunction = ({ options: fetchOptions }) => {\n            // Create XMLHttpRequest\n            const xhr = new XMLHttpRequest();\n            const method = (requestOptions.method || 'GET').toUpperCase();\n            // Create a promise that wraps the XHR request\n            const xhrPromise = new Promise((resolve, reject) => {\n                xhr.onload = function() {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        let response = xhr.response;\n                        if (requestOptions.responseType === 'json' ||\n                            (xhr.getResponseHeader('Content-Type') && xhr.getResponseHeader('Content-Type').includes('application/json'))) {\n                            try {\n                                response = JSON.parse(xhr.responseText);\n                            } catch (e) {\n                                response = xhr.responseText;\n                            }\n                        }\n                        resolve({\n                            data: response,\n                            status: xhr.status,\n                            statusText: xhr.statusText,\n                            headers: xhr.getAllResponseHeaders(),\n                            xhr: xhr\n                        });\n                    } else {\n                        reject({\n                            message: `Request failed with status ${xhr.status}`,\n                            status: xhr.status,\n                            statusText: xhr.statusText,\n                            xhr: xhr\n                        });\n                    }\n                };\n                xhr.onerror = function() {\n                    reject({\n                        message: 'Network error',\n                        xhr: xhr\n                    });\n                };\n                xhr.ontimeout = function() {\n                    reject({\n                        message: 'Request timeout',\n                        xhr: xhr\n                    });\n                };\n\n                // Open the request\n                xhr.open(method, url, true);\n\n                // Set response type\n                if (requestOptions.responseType) xhr.responseType = requestOptions.responseType;\n                // Set withCredentials\n                if (requestOptions.withCredentials !== undefined) xhr.withCredentials = requestOptions.withCredentials;\n                // Set timeout\n                if (requestOptions.timeout !== undefined) xhr.timeout = requestOptions.timeout;\n                // Set headers\n                if (requestOptions.headers) Object.keys(requestOptions.headers).forEach(key => {\n                    xhr.setRequestHeader(key, requestOptions.headers[key]);\n                });\n\n                // Connect abort signal to xhr.abort()\n                if (fetchOptions.signal) fetchOptions.signal.addEventListener('abort', () => xhr.abort());\n\n                // Send the request\n                xhr.send(requestOptions.body || null);\n            });\n            return xhrPromise;\n        };\n        return this.#_request(requestId, xhrFunction, requestOptions);\n    }\n\n    /**\n     * Cancels a specific request by its identifier.\n     * \n     * @param {string} requestId - The unique identifier of the request to cancel\n     * @returns {boolean} True if the request was found and cancelled, false otherwise\n     */\n    cancel(requestId) {\n        const requestInfo = this.activeRequests.get(requestId);\n        if (!requestInfo) return false;\n\n        requestInfo.isCancelled = true; // Mark as cancelled\n\n        // Try to abort using AbortController (for fetch)\n        if (requestInfo.abortController && !requestInfo.abortController.signal.aborted) {\n            try {\n                requestInfo.abortController.abort('Request was cancelled');\n            } catch (error) {}\n        }\n\n        // Try to cancel using cancel token/function (for axios and others)\n        if (requestInfo.cancelToken) {\n            try {\n                if (typeof requestInfo.cancelToken === 'function') requestInfo.cancelToken();\n                else if (requestInfo.cancelToken.cancel) requestInfo.cancelToken.cancel();\n            } catch (error) {}\n        }\n\n        // Reject the wrapper promise\n        if (requestInfo.rejectWrapper && this.verbose) {\n            requestInfo.rejectWrapper(new Error(`Request ${requestId} was cancelled`));\n        }\n        this.activeRequests.delete(requestId); // Remove from active requests\n        return true;\n    }\n\n    /**\n     * Link abort signal with HTTP client abort method.\n     * Useful for custom HTTP clients that only support the abort method to cancel requests.\n     * @param {Function} abortMethod - The abort method to call when the signal is aborted\n     * @param {AbortSignal} signal - The signal to listen to\n     */\n    addAbortListener(abortMethod, signal) {\n        if (!signal) return;\n        signal.addEventListener(\"abort\", () => {\n            if (typeof abortMethod === 'function') {\n                try {\n                    abortMethod();\n                } catch (error) {}\n            }\n        });\n    }\n\n    /**\n     * Cancels all active requests.\n     * \n     * @returns {number} The number of requests that were cancelled\n     */\n    cancelAll() {\n        const requestIds = Array.from(this.activeRequests.keys());\n        let cancelledCount = 0;\n        requestIds.forEach((requestId) => {\n            if (this.cancel(requestId)) cancelledCount++;\n        });\n        return cancelledCount;\n    }\n\n    /**\n     * Checks if a request with the given identifier is currently active.\n     * \n     * @param {string} requestId - The unique identifier to check\n     * @returns {boolean} True if the request is active, false otherwise\n     */\n    isActive(requestId) {\n        return this.activeRequests.has(requestId);\n    }\n\n    /**\n     * Gets the number of active requests.\n     * \n     * @returns {number} The number of currently active requests\n     */\n    getActiveCount() {\n        return this.activeRequests.size;\n    }\n\n    /**\n     * Clears all active requests without cancelling them.\n     * Use with caution - this will not cancel the underlying HTTP requests.\n     */\n    clear() {\n        this.activeRequests.clear();\n    }\n}\n\nexport default RequestManager;\n\nexport { RequestManager };\n"],"names":[],"mappings":"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"}