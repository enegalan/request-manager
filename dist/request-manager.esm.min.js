/**
 * RequestManager - A library for managing and regulating HTTP requests efficiently.
 * @license MIT
 * This library allows you to manage HTTP requests from any library (ajax, Ext.Ajax, axios, fetch, etc.)
 * by accepting Promises as parameters. When a request is repeated with the same identifier,
 * the previous request is automatically cancelled and the new one is executed, giving priority to the most recent requests.

 * @param {Object} managerOptions - The options for the manager
 * @param {boolean} managerOptions.verbose - If true, cancellation errors will include messages
 * @returns {RequestManager} A new RequestManager instance
*/
class e{constructor(e={}){this.activeRequests=new Map,this.verbose=e.verbose||!1,this.managerOptions=e,this.options={},this.abortController=null}#e(){this.options={}}getOptions(){return this.managerOptions}setOptions(e){this.managerOptions=e,void 0!==e.verbose&&(this.verbose=e.verbose)}#t(e){this.options=e}getSignal(){return this.getAbortController().signal}getAbortController(){return this.abortController&&!this.abortController.signal.aborted||(this.abortController=new AbortController),this.abortController}#s(){this.abortController=null}#r(e,t=null,s=!1){if(s)return`request_${Date.now()}_${Math.random().toString(36).slice(2,11)}`;if(null!=t){if("function"==typeof t)try{t=t()}catch(e){t=null}if(null!=t)return`request_${String(t)}`}let r=e||"";return r.includes("://")&&(r=r.split("://")[1]),r.includes("?")&&(r=r.split("?")[0]),r.includes("#")&&(r=r.split("#")[0]),`request_${r}`}#n(e,t,s={}){const r=Object.assign({},s),n=["abortController","cancelToken","requestKey","noCancel"];return Object.keys(e).forEach(t=>{n.includes(t)||(r[t]=e[t])}),r.signal=t,r}#o(e,t,s={}){this.#t(s),s.abortController||this.#s(),this.#e();const r=s.abortController||this.getAbortController();if("function"==typeof t){const l=this.#n(s,r.signal);t=t({options:l})}else if("string"==typeof t){const c=this.#n(s,r.signal);t=fetch(t,c)}let n,o;s.noCancel||this.cancel(e);const a=new Promise((e,t)=>{n=e,o=t}),i={promise:t,abortController:r,cancelToken:s.cancelToken||null,wrapperPromise:a,resolveWrapper:n,rejectWrapper:o,isCancelled:!1,verbose:this.verbose};if(this.activeRequests.set(e,i),t&&"function"==typeof t.then){try{let h=t.then(t=>{this.activeRequests.get(e)!==i||i.isCancelled||(this.activeRequests.delete(e),n(t))});h.catch&&h.catch(e=>{u(this,e)})}catch(p){u(this,p)}function u(t,s){t.activeRequests.get(e)===i&&(t.activeRequests.delete(e),i.isCancelled?i.isCancelled&&i.verbose&&o(new Error("Request was cancelled")):o(s))}}else setTimeout(()=>{this.activeRequests.get(e)!==i||i.isCancelled||(this.activeRequests.delete(e),n(t))},0);return a}request(e,t,s={}){const r=s||{},n=this.#r(e,r.requestKey,r.noCancel);return this.#o(n,t,r)}fetch(e,t={}){const s=t||{},r=this.#r(e,s.requestKey,s.noCancel);return this.#o(r,e,s)}axios(e,t={},s=null){const r=t||{},n=s||axios,o=n.CancelToken.source(),a=this.#r(e,r.requestKey,r.noCancel);return this.#o(a,n.get(e,{cancelToken:o.token,...r}),{cancelToken:o,...r})}ajax(e,t,s={}){if("function"!=typeof e)throw new Error("ajaxFunction parameter must be a function");const r=s||{},n=this.#r(t,r.requestKey,r.noCancel);try{const o=s.abortController||this.getAbortController(),a=e({url:t,...r});return console.log("req",a,typeof a.abort),a&&"function"==typeof a.abort&&this.addAbortListener(a.abort,o.signal),this.#o(n,a,{...r,abortController:o})}catch(e){return Promise.reject(e)}}xhr(e,t={}){const s=t||{},r=this.#r(e,s.requestKey,s.noCancel);return this.#o(r,({options:t})=>{const r=new XMLHttpRequest,n=(s.method||"GET").toUpperCase();return new Promise((o,a)=>{r.onload=function(){if(r.status>=200&&r.status<300){let e=r.response;if("json"===s.responseType||r.getResponseHeader("Content-Type")&&r.getResponseHeader("Content-Type").includes("application/json"))try{e=JSON.parse(r.responseText)}catch(t){e=r.responseText}o({data:e,status:r.status,statusText:r.statusText,headers:r.getAllResponseHeaders(),xhr:r})}else a({message:`Request failed with status ${r.status}`,status:r.status,statusText:r.statusText,xhr:r})},r.onerror=function(){a({message:"Network error",xhr:r})},r.ontimeout=function(){a({message:"Request timeout",xhr:r})},r.open(n,e,!0),s.responseType&&(r.responseType=s.responseType),void 0!==s.withCredentials&&(r.withCredentials=s.withCredentials),void 0!==s.timeout&&(r.timeout=s.timeout),s.headers&&Object.keys(s.headers).forEach(e=>{r.setRequestHeader(e,s.headers[e])}),t.signal&&t.signal.addEventListener("abort",()=>r.abort()),r.send(s.body||null)})},s)}cancel(e){const t=this.activeRequests.get(e);if(!t)return!1;if(t.isCancelled=!0,t.abortController&&!t.abortController.signal.aborted)try{t.abortController.abort("Request was cancelled")}catch(e){}if(t.cancelToken)try{"function"==typeof t.cancelToken?t.cancelToken():t.cancelToken.cancel&&t.cancelToken.cancel()}catch(e){}return t.rejectWrapper&&this.verbose&&t.rejectWrapper(new Error(`Request ${e} was cancelled`)),this.activeRequests.delete(e),!0}addAbortListener(e,t){t&&t.addEventListener("abort",()=>{if("function"==typeof e)try{e()}catch(e){}})}cancelAll(){const e=Array.from(this.activeRequests.keys());let t=0;return e.forEach(e=>{this.cancel(e)&&t++}),t}isActive(e){return this.activeRequests.has(e)}getActiveCount(){return this.activeRequests.size}clear(){this.activeRequests.clear()}}export{e as RequestManager,e as default};
//# sourceMappingURL=request-manager.esm.min.js.map
